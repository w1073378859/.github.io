<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>框架面试题</title>
    <link href="/2021/07/21/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/07/21/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h2 id="什么是-Mybatis？"><a href="#什么是-Mybatis？" class="headerlink" title="什么是 Mybatis？"></a>什么是 Mybatis？</h2><p>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。<br>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。<br>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返回 result 的过程）。</p><h2 id="Mybaits-的优点"><a href="#Mybaits-的优点" class="headerlink" title="Mybaits 的优点"></a>Mybaits 的优点</h2><p>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。<br>与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；<br>很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。<br>能够与 Spring 很好的集成；<br>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p><h2 id="MyBatis-框架的缺点"><a href="#MyBatis-框架的缺点" class="headerlink" title="MyBatis 框架的缺点"></a>MyBatis 框架的缺点</h2><p>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。<br>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h2 id="MyBatis-框架适用场合"><a href="#MyBatis-框架适用场合" class="headerlink" title="MyBatis 框架适用场合"></a>MyBatis 框架适用场合</h2><p>MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。<br>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是不错的选择。</p><h2 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h2><p>Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句。<br>Mybatis 直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映射文件，工作量大。<br>Hibernate 对象 / 关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用 hibernate 开发可以节省很多代码，提高效率。</p><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a>#{} 和 ${} 的区别是什么？</h2><pre><code>#&#123;&#125; 是预编译处理，$&#123;&#125; 是字符串替换。#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id，如果传入的值是 111, 那么解析成 sql 时的值为 order by “111”, 如果传入的值是 id，则解析成的 sql 为 order by “id”</code></pre><p>$ 将传入的数据直接显示生成在 sql 中。如：order by $user_id，如果传入的值是 111, 那么解析成 sql 时的值为 order by user_id, 如果传入的值是 id，则解析成的 sql 为 order by id<br>    #方式能够很大程度防止 sql 注入<br>$ 方式无法防止 Sql 注入<br>$ 方式一般用于传入数据库对象，例如传入表名<br>一般能用 #的就别用 $<br>MyBatis 排序时使用 order by 动态参数时需要注意，用 $ 而不是#<br>字符串替换:</p><p>默认情况下，使用 #{} 格式的语法会导致 MyBatis 创建预处理语句属性并以它为背景设置安全的值（比如？）。这样做很安全，很迅速也是首选做法，有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 ORDER BY，你可以这样来使用：</p><p>ORDER BY ${columnName}</p><p>这里 MyBatis 不会修改或转义字符串</p><p>重要：接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的 SQL 注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查</p><h2 id="通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h2><p>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。</p><p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个 <select>、<insert>、<update>、<delete> 标签，都会被解析为一个 MapperStatement 对象。</p><p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为 findStudentById 的 MapperStatement。</p><p>Mapper 接口里的方法，是不能重载的，因为是使用 全限名 + 方法名 的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</p><h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。<br>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？<br>使用 <resultMap> 标签，逐一定义数据库列名和对象属性名之间的映射关系。<br>使用 sql 列的别名功能，将列的别名书写为对象属性名。<br>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h2 id="Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql？"><a href="#Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql？" class="headerlink" title="Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？"></a>Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？</h2><p>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。</p><p>Mybatis 提供了 9 种动态 sql 标签：</p><p>trim<br>where<br>set<br>foreach<br>if<br>choose<br>when<br>otherwise<br>bind</p><h2 id="Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h2><p><resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态 sql 的 9 个标签，其中 <sql> 为 sql 片段标签，通过 <include> 标签引入 sql 片段，<selectKey> 为不支持自增的主键生成策略标签。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题2</title>
    <link href="/2021/07/15/%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <url>/2021/07/15/%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Executors-框架？"><a href="#什么是-Executors-框架？" class="headerlink" title="什么是 Executors 框架？"></a>什么是 Executors 框架？</h2><p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executors 框架可以非常方便的创建一个线程池。</p><h2 id="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队-列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队-列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队 列来实现生产者 - 消费者模型？"></a>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队 列来实现生产者 - 消费者模型？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p><p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7 提供了 7 个阻塞队列。分别是:</p><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。<br>Java5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized 这些关键字。而在 java5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p><p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p><p>阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p><h2 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a>什么是 Callable 和 Future?</h2><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p><p>可以认为是带有回调的 Runnable。</p><p>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p><h2 id="什么是-FutureTask-使用-ExecutorService-启动任务。"><a href="#什么是-FutureTask-使用-ExecutorService-启动任务。" class="headerlink" title="什么是 FutureTask? 使用 ExecutorService 启动任务。"></a>什么是 FutureTask? 使用 ExecutorService 启动任务。</h2><p>在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable 接口所以它可以提交给 Executor 来执行。</p><h2 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h2><p>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行 。比如 Vector ， Hashtable， 以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。</p><p>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</p><h2 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h2><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p><p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。</p><p>内核模式下的方法有：事件，信号量，互斥量。</p><h2 id="什么是竞争条件？你怎样发现和解决竞争？"><a href="#什么是竞争条件？你怎样发现和解决竞争？" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争？"></a>什么是竞争条件？你怎样发现和解决竞争？</h2><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。</p><p>为什么我们调用 start () 方法时会执行 run () 方法，为什么我们不能直接调用 run () 方法？<br>当你调用 start () 方法时你将创建新的线程，并且执行在 run () 方法里的代码。但是如果你直接调用 run () 方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。</p><h2 id="Java-中你怎样唤醒一个阻塞的线程？"><a href="#Java-中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java 中你怎样唤醒一个阻塞的线程？"></a>Java 中你怎样唤醒一个阻塞的线程？</h2><p>在 Java 发展史上曾经使用 suspend ()、resume () 方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。</p><p>解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait () 和 notify () 方法实现线程阻塞。</p><p>首先，wait、notify 方法是针对对象的，调用任意对象的 wait () 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify () 方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p><h2 id="在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？"><a href="#在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？" class="headerlink" title="在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？"></a>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</h2><p>`CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。</p><p>Java 的 concurrent 包里面的 CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。</p><p>可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 await () 方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。</p><p>所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次 —— 计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。</p><p>CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到 其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一 个 CountDownLatch 对象的 await () 方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 countDown () 方法，这个调用 await () 方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止</p><p>CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程面试题</title>
    <link href="/2021/06/29/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/06/29/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="在-java-中守护线程和本地线程区别？"><a href="#在-java-中守护线程和本地线程区别？" class="headerlink" title="在 java 中守护线程和本地线程区别？"></a>在 java 中守护线程和本地线程区别？</h2><p>java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p><p>任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(布尔类型)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon() 必须在 Thread.start() 之前调用，否则运行时会抛出异常。</p><h3 id="两者的区别："><a href="#两者的区别：" class="headerlink" title="两者的区别："></a>两者的区别：</h3><p>唯一的区别是判断虚拟机 (JVM) 何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</p><p>扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</p><h2 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a>线程与进程的区别？</h2><p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p><p>一个程序至少有一个进程，一个进程至少有一个线程。</p><h2 id="什么是多线程中的上下文切换？"><a href="#什么是多线程中的上下文切换？" class="headerlink" title="什么是多线程中的上下文切换？"></a>什么是多线程中的上下文切换？</h2><p>多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU 发生的切换数据等就是上下文切换。</p><h2 id="死锁与活锁的区别，死锁与饥饿的区别？"><a href="#死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h2><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><h3 id="产生死锁的必要条件："><a href="#产生死锁的必要条件：" class="headerlink" title="产生死锁的必要条件："></a>产生死锁的必要条件：</h3><p>互斥条件：所谓互斥就是进程在某一时间内独占资源。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件: 进程已获得资源，在末使用完之前，不能强行剥夺。<br>循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。<br>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的 “活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><h3 id="Java-中导致饥饿的原因："><a href="#Java-中导致饥饿的原因：" class="headerlink" title="Java 中导致饥饿的原因："></a>Java 中导致饥饿的原因：</h3><p>高优先级线程吞噬所有的低优先级线程的 CPU 时间。<br>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。<br>线程在等待一个本身也处于永久等待完成的对象 (比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</p><h2 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h2><p>采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。</p><h2 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h2><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p><p>为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。</p><h2 id="为什么使用-Executor-框架？"><a href="#为什么使用-Executor-框架？" class="headerlink" title="为什么使用 Executor 框架？"></a>为什么使用 Executor 框架？</h2><p>每次执行任务创建线程 new Thread() 比较消耗性能，创建一个线程是比较耗时、耗资源的。调用 new Thread() 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</p><p>接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p><h2 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h2><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。<br>Executor 接口对象能执行我们的线程任务。<br>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。<br>使用 ThreadPoolExecutor 可以创建自定义线程池<br>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get() 方法获取计算的结果。</p><h2 id="什么是原子操作？在-Java-Concurrency-API-中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在-Java-Concurrency-API-中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在 Java Concurrency API 中有哪些原子类 (atomic classes)？"></a>什么是原子操作？在 Java Concurrency API 中有哪些原子类 (atomic classes)？</h2><p>原子操作（atomic operation）意为” 不可被中断的一个或一系列操作” 。</p><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p>在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作 ——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</p><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p><p>int++ 并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p><p>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和 long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p><p>java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p><p>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</p><p>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</p><p>原 子 属 性 更 新 器 ： AtomicLongFieldUpdater ， AtomicIntegerFieldUpdater ，AtomicReferenceFieldUpdater</p><p>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean 来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）</p><h2 id="Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？-对比同步它有什么优势？"><a href="#Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？-对比同步它有什么优势？" class="headerlink" title="Java Concurrency API 中的 Lock 接口 (Lock interface) 是什么？ 对比同步它有什么优势？"></a>Java Concurrency API 中的 Lock 接口 (Lock interface) 是什么？ 对比同步它有什么优势？</h2><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：</p><p>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的 (tryLock 方法)、定时的 (tryLock 带参方法)、可中断的 (lockInterruptibly)、可多条件队列的 (newCondition 方法) 锁操作。另外 Lock 的实现类基本都支持非公平锁 (默认) 和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择</p>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/22/hello-world/"/>
    <url>/2021/06/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
